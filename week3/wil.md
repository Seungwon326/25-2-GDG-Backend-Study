# 3주차 - JPA와 레포지토리

- Repository - 데이터베이스에 접근하여 CRUD 작업을 수행하는 계층
    - Create - 데이터 생성
    - Read - 데이터 조회
    - Update- 기존 데이터 수정
    - Delete - 데이터 삭제
- 데이터베이스에 접근하려면?
    - 어플리케이션 서버가 SQL을 연결된 커넥션을 통해 DB에 전달
    - DB는 전달된 SQL을 수행하고 그 결과를 응답
    - 어플리케이션 서버는 결과를 활용
- JDBC - Java에서 DB에 접근하기 위한 표준화된 API
- SQL을 다루는 방법 복잡 → ORM으로 해결
    - ORM - 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것
    - 반복적인 CRUD SQL 자동으로 처리, 패러다임 차이 해결
- JPA - 자바 진영의 ORM 기술 표준
    - 자바에서 객체를 데이트베이스에 저장하고 관리하기 위한 인터페이스와 기능을 제공하는 API
    - Entity Manager - 엔티티 객체를 데이터베이스와 연결해주는 창구 역할
        - SQL을 직접 작성하지 않고도 엔티티를 데이터베이스에 등록/수정/조회/삭제 가능
            - 엔티티 - 데이터베이스에 저장할 객체, 테이블과 1:1 매핑되는 객체
            - 등록 - em.persist()
                - 쓰기 지연 - DB에 바로 쓰는 것이 아니라 변경사항들을 모아두었다가 트랜잭션이 완료되는 시점에 한 번에 묶어서 DB에 보내는 구조(성능 최적화)
            - 조회 - em.find()
                - 1차 캐시 - 한 번 조회한 객체를 영속성 컨텍스트가 내부네 저장해두고 재사용하는 구조
                - 동일성 보장 - 트랜잭션 안에서 같은 엔티티를 여러번 조회해도 항상 동일한 객체임이 보장
            - 수정 - 엔티티의 조회 후 수정 후 em.flush() → 엔티티의 최초 상태와 현재 상태를 비교
                - 엔티티가 변경되면 자동으로 UPDATE 쿼리를 생성해서 DB에 보냄 → 변경 감지
                - 변경 감지 - 영송성 컨텍스트가 엔티티의 변경 사항을 자동으로 감지하고, 트랜잭션 커밋 시점에 변경 내용을 DB에 반영하는 것(영속 상태의 엔티티에만 적용)
            - 삭제 - em.remove()
    - 엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장
        - 영속성 컨텍스트 - JPA에서 엔티티를 관리하기 위해서 만들어져있는 **가상 공간**(어플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상 공간)
            - 영속성 컨텍스트의 장점: 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지
                - 트랜잭션 - 데이터베이스에서 수행되는 작업의 단위(더 이상 쪼갤 수 없음 = 원자성)
                - ex) [주문 정보 저장] → [상품 재고 차감] → [회원 포인트 적립] → 커밋 → DB에 반영
                - 만약 [상품 재고 차감]에서 에러가 생기면 처음으로 롤백(모든 작업이 완료 되어야 커밋)
